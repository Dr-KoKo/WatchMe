
- 목차

# 상속관계 매핑

## 상속관계 매핑

- 관계형 데이터베이스는 상속 관계X
- 슈퍼타입 서브타입 관계라는 모델링 기벙이 객체 상속과 유사
- 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aaf7ec0a-8221-4ff6-a264-4300e7c09d45/Untitled.png)

→ 상속을 지원하지는 않는다.

- **슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법**
    - 각각 테이블로 변환 → 조인 전략
    - 통합 테이블로 변환  → 단일 테이블 전략
    - 서브타입 테이블로 변환 → 구현 클래스마다 테이블 전략

---

## 조인 전략

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/efb5f457-b066-42b4-b097-56b030da7f7d/Untitled.png)

필요할 경우 조인을 한다.

부모 부분을 따로 테이블로 만들어 조인 함으로서 만든다.

---

### 단일 테이블 전략

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eedea1f0-9a25-45de-933f-09d179d5c556/Untitled.png)

논리 모델을 하나로 합치는 것입니다.

해당하지 않는 것은 NULL로 DTYPE으로 구분

---

## 구현 클래스마다 테이블 전략

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5105053e-df30-4739-80f7-08410ddeca09/Untitled.png)

각각 따로 만들어줍니다.

---

객체 입장에서는 하나인데 DB에서는 여러개로 구현이 될 수 있다.

객체 지향적이지 않은 상황이다.

## 결론

상속관계 매핑은 수퍼타입 서브타입 관계를 모델링 기법으로 다 매핑을 하도록 지원을 해준다.

---

## 주요 어노테이션

## 조인

DB에서 조인하는 방식으로 해결을 하면 데이터가 정교 해진다.

JPA에서 가장 유사한 내용이기는 하다.

코드로 보자

**CODE**

- Item.java
    
    ```java
    package hellojpa;
    
    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.Id;
    
    @Entity
    public class Item {
    
        @Id @GeneratedValue
        private Long id;
    
        private String name;
        private int price;
    
    }
    ```
    
- Album.java
    
    ```java
    package hellojpa;
    
    import javax.persistence.Entity;
    @Entity
    public class Album extends Item{
            private String artist;
    }
    ```
    
- Movie.java
    
    ```java
    package hellojpa;
    
    import javax.persistence.Entity;
    
    @Entity
    public class Movie extends Item{
        private String director;
        private String artist;
    }
    ```
    
- Book.java
    
    ```java
    package hellojpa;
    
    import javax.persistence.Entity;
    
    @Entity
    public class Book extends Item{
    
        private String writer;
        private String isbn;
    }
    ```
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/191f254f-cdd1-453d-b8f6-4c8a1f6abbb9/Untitled.png)

단일 테이블 생성

→ JPA는 **단일 테이블 전략**이 기본이다

그렇다면 다른 전략을 어떻게 선택하는가?

→ 어노테이션 **@Inheritance(strategy = InheritanceType.JOINED**) 사용

- Item.java
    
    ```java
    package hellojpa;
    
    import javax.persistence.*;
    
    @Entity
    @Inheritance(strategy = InheritanceType.JOINED)
    public class Item {
    
        @Id @GeneratedValue
        private Long id;
    
        private String name;
        private int price;
    
    }
    ```
    
    ```java
    @Inheritance(strategy = InheritanceType.JOINED)
    ```
    
    전략을 다음과 같이 JOINED로 하겠다!
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da54898b-c96e-4222-94b6-a22b8197539c/Untitled.png)

다음과 같이 따로 따로 설계되는 것을 확인 할 수 있다.

- JpaMain.java
    
    ```java
    package hellojpa;
    
    import javax.persistence.EntityManager;
    import javax.persistence.EntityManagerFactory;
    import javax.persistence.EntityTransaction;
    import javax.persistence.Persistence;
    import java.util.List;
    
    public class JpaMain {
    
        public static void main(String[] args) {
            EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");
    
            EntityManager em = emf.createEntityManager();
    
            EntityTransaction tx = em.getTransaction();
            tx.begin();
    
            try {
                System.out.println("AAAAAA");
                Movie movie = new Movie();
                movie.setDirector("aaaa");
                movie.setActor("bbbb");
                movie.setName("바람과함께사라지다");
                movie.setPrice(10000);
    
                em.persist(movie);
    
                em.flush();
                em.clear();
    
                Movie findMovie = em.find(Movie.class, movie.getId());
                System.out.println("findMovie = " + findMovie);
                tx.commit();
            } catch (Exception e) {
                System.out.println("ERROR");
                tx.rollback();
            } finally {
                em.close();
            }
        }
    }
    ```
    

```java
						Movie findMovie = em.find(Movie.class, movie.getId());
            System.out.println("findMovie = " + findMovie);
```

에 대하여

```
Hibernate: 
    select
        movie0_.id as id2_2_0_,
        movie0_1_.name as name3_2_0_,
        movie0_1_.price as price4_2_0_,
        movie0_.Actor as Actor1_6_0_,
        movie0_.director as director2_6_0_ 
    from
        Movie movie0_ 
    inner join
        Item movie0_1_ 
            on movie0_.id=movie0_1_.id 
    where
        movie0_.id=?
findMovie = hellojpa.Movie@3a60c416
```

다음과 같이 자동으로 join이 되어서 질문이 나오는 것을 알 수 있습니다.

### `@DiscriminatorColumn`

Item.java

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn
public class Item {
```

다음과 같이 @DiscriminatorColumn 어노테이션을 넣어줍니다.

다음과 같이 DTYPE이 자동으로 생성됩니다.

```
create table Item (
       DTYPE varchar(31) not null,
        id bigint not null,
        name varchar(255),
        price integer not null,
        primary key (id)
    )
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8ed63175-0f31-4160-83b4-c826fa5389bd/Untitled.png)

### `@DiscriminatorValue()`

Dtype을 지정해줄 수 있습니다.

## 단일 테이블 전략

조인이 너무 복잡하다 하나로 만들자

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98228506-bc58-40f8-81a1-224edff72d42/Untitled.png)

- Item.java
    
    ```java
    package hellojpa;
    
    import javax.persistence.*;
    
    @Entity
    @Inheritance(strategy = InheritanceType.SINGLE_TABLE)
    @DiscriminatorColumn
    public class Item {
    
        @Id @GeneratedValue
        private Long id;
    
        private String name;
        private int price;
    
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getPrice() {
            return price;
        }
    
        public void setPrice(int price) {
            this.price = price;
        }
    }
    ```
    

`@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`

다음과 같이 선언해줘서 단일 테이블로 바꿔줍니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4aed610c-57d0-4e11-8bd8-6e07f4a58ad5/Untitled.png)

다음과 같이 하나의 테이블로 선언이 됩니다.

성능 상 빠름

### `@DiscriminatorValue()`

이 어노테이션이 없어도 상관이 없다.

## 구현 클래스마다 테이블 전략

- Item.java
    
    ```java
    package hellojpa;
    
    import javax.persistence.*;
    
    @Entity
    @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
    @DiscriminatorColumn
    public abstract class Item {
    
        @Id @GeneratedValue
        private Long id;
    
        private String name;
        private int price;
    
        public Long getId() {
            return id;
        }
    
        public void setId(Long id) {
            this.id = id;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getPrice() {
            return price;
        }
    
        public void setPrice(int price) {
            this.price = price;
        }
    }
    ```
    

이 전략은 개별적으로 볼때는 편하지만 ITEM전체에 대한 조회를 하게 될 경우 다 합쳐서 찾아야 됩니다.

→ **복잡한 쿼리가 발생한다.**

**비효율적이다.**

## 결론

### 조인 전략의 장단점

**장점**

- 테이블 정규화
- 외래 키 참조 무결성 제약 조건 활용가능
- 저장 공간 효율화
- 

**단점**

- 조회 시 조인을 많이 사용, 성능 저하
- 조회 커리가 복잡함
- 데이터 저장시 INSERT SQL 2번 호출

**→ 그래도 이것이 기본이다.**

### 단일 테이블 전략의 장단점

**장점**

- 조인이 필요 없음 , 일반적으로 조회 성능이 빠름
- 조회 쿼리가 단순함

**단점**

- 자식 엔티티가 매핑한 컬럼은 모두 NULL 허용
- 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있는 상황에 따라서 조회 성능이 오히려 느려질 수 있다.

### 구현 클래스마다 테이블 전략

이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천 X

장점

- 서브 타입을 명확하게 구분해서 처리할 때 효과적
- not null  제약조건 사용 가능

단점

- 여러 자식 테이블을 함께 조회할 때 성능이 느림
- 자식 테이블을 통합해서 쿼리하기 어려움

## 상속관계 매핑

관계형 데이터베이스는 상속 관계X
슈퍼 타입 서브 타입 관계라는 모델링 기법이 객체 상속과 유사

상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
